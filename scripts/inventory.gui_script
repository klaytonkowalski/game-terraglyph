--------------------------------------------------------------------------------
-- DEPENDENCIES
--------------------------------------------------------------------------------

local m_item = require "modules.item"
local m_persist = require "modules.persist"
local m_dcolors = require "dcolors.dcolors"
local m_dtypewriter = require "dtypewriter.dtypewriter"
local m_monarch = require "monarch.monarch"

--------------------------------------------------------------------------------
-- CONSTANTS
--------------------------------------------------------------------------------

local c_acquire_input_focus = hash("acquire_input_focus")

local c_monogram = hash("monogram")

local c_state_inventory = hash("state_inventory")
local c_state_action = hash("state_action")
local c_state_party = hash("state_party")

local c_selector_inventory = hash("selector_inventory")
local c_selector_stats = hash("selector_stats")

local c_dialog_background = hash("dialog_background")
local c_action_background = hash("action_background")
local c_party_background = hash("party_background")
local c_stats_background = hash("stats_background")

local c_use = hash("use")
local c_consume = hash("consume")
local c_equip = hash("equip")
local c_drop = hash("drop")

local c_spinner = hash("spinner")

local c_key_up = hash("key_up")
local c_key_left = hash("key_left")
local c_key_down = hash("key_down")
local c_key_right = hash("key_right")
local c_key_z = hash("key_z")
local c_key_x = hash("key_x")
local c_key_lctrl = hash("key_lctrl")
local c_key_enter = hash("key_enter")

--------------------------------------------------------------------------------
-- PROPERTIES
--------------------------------------------------------------------------------

local p_state = c_state_inventory

local p_inventory_index = 1
local p_inventory = {}

local p_action_index = 1
local p_action_ids = {}

local p_party_index = 1
local p_party_ids = {}
local p_party = {}

--------------------------------------------------------------------------------
-- LOCAL FUNCTIONS
--------------------------------------------------------------------------------

local function load_inventory()
	p_inventory = m_persist.get_inventory()
	for index, data in ipairs(p_inventory) do
		if data then
			local item_node = gui.get_node(hash("item_" .. index))
			gui.set_enabled(item_node, true)
			gui.play_flipbook(item_node, data.key .. "_idle")
		end
	end
end

local function load_party()
	p_party = m_persist.get_party()
	for index, data in ipairs(p_party) do
		if data then
			p_party_ids[#p_party_ids + 1] = hash("party_" .. index)
			local party_node = gui.get_node(p_party_ids[#p_party_ids])
			gui.set_text(party_node, data.name)
		end
	end
end

local function get_item_dialog(item)
	return "<color=item>" .. item.name .. "<color=default><line>" .. item.description
end

local function calculate_equipment_stats(player)
	local result =
	{
		totals = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		hands = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		head = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		torso = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		trunk = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		feet = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		ring = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		bracelet = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 },
		necklace = { health = 0, strength = 0, defense = 0, agility = 0, wonder = 0, terra = 0 }
	}
	for _, category in ipairs({ "hands", "head", "torso", "trunk", "feet", "ring", "bracelet", "necklace" }) do
		local item_key = player[category .. "_key"]
		if item_key then
			local item = m_item[item_key]
			for _, stat in ipairs({ "health", "strength", "defense", "agility", "wonder", "terra" }) do
				result.totals[stat] = result.totals[stat] + item[stat]
				result[category][stat] = result[category][stat] + item[stat]
			end
		end
	end
	return result
end

local function refresh_stats_background()
	local item = m_item[p_inventory[p_inventory_index].key]
	local player = p_party[p_party_index]
	local equipment_stats = calculate_equipment_stats(player)
	for _, stat in ipairs({ "health", "strength", "defense", "agility", "wonder", "terra" }) do
		local level_node = gui.get_node(hash(stat .. "_level"))
		local level_string = player[stat]
		gui.set_text(level_node, level_string)
		local delta_node = gui.get_node(hash(stat .. "_delta"))
		local delta_value = item[stat] - equipment_stats[item.category][stat]
		gui.set_text(delta_node, delta_value > 0 and "+" .. delta_value or delta_value)
		gui.set_color(delta_node, delta_value == 0 and m_dcolors.palette.brown_4 or (delta_value > 0 and m_dcolors.palette.green or m_dcolors.palette.red))
		local total_node = gui.get_node(hash(stat .. "_total"))
		local total_string = equipment_stats.totals[stat] + player[stat] + delta_value
		gui.set_text(total_node, total_string)
		gui.set_color(total_node, delta_value == 0 and m_dcolors.palette.brown_4 or (delta_value > 0 and m_dcolors.palette.green or m_dcolors.palette.red))
		local equipment_node = gui.get_node(hash(stat .. "_equipment"))
		local equipment_string = equipment_stats.totals[stat] + delta_value
		gui.set_text(equipment_node, equipment_string)
		gui.set_color(equipment_node, delta_value == 0 and m_dcolors.palette.brown_4 or (delta_value > 0 and m_dcolors.palette.green or m_dcolors.palette.red))
	end
	for _, category in ipairs({ "hands", "head", "torso", "trunk", "feet", "ring", "bracelet", "necklace" }) do
		local node = gui.get_node(hash(category))
		if player[category .. "_key"] then
			gui.set_enabled(node, true)
			if item.category == category then
				gui.play_flipbook(node, player[category .. "_key"] .. "_active")
				local player_item_name = m_item[player[category .. "_key"]].name
				m_dtypewriter.load("Equip <color=item>" .. item.name .. "<color=default> and unequip <color=item>" .. player_item_name .. "<color=default>?")
			else
				gui.play_flipbook(node, player[category .. "_key"] .. "_idle")
			end
		else
			gui.set_enabled(node, false)
		end
	end
	if not m_dtypewriter.is_loaded() then
		m_dtypewriter.load("Equip <color=item>" .. item.name .. "<color=default>?")
	end
	m_dtypewriter.start()
	local node_selector = gui.get_node(c_selector_stats)
	local node_selectee = gui.get_node(hash(item.category))
	local selector_position = gui.get_position(node_selectee)
	gui.set_position(node_selector, selector_position)
end

local function check_equipable(player, item)
	return player.health >= item.require_health and player.strength >= item.require_strength and player.defense >= item.require_defense and player.agility >= item.require_agility and player.wonder >= item.require_wonder and player.terra >= item.require_terra
end

local function select_inventory_index(index)
	if p_inventory[p_inventory_index] then
		gui.play_flipbook(gui.get_node(hash("item_" .. p_inventory_index)), p_inventory[p_inventory_index].key .. "_idle")
		m_dtypewriter.clear()
	end
	if index < 1 then
		p_inventory_index = #p_inventory + index
	elseif index > #p_inventory then
		p_inventory_index = index - #p_inventory
	else
		p_inventory_index = index
	end
	local next_node = gui.get_node(hash("item_" .. p_inventory_index))
	if p_inventory[p_inventory_index] then
		local next_inventory_data = p_inventory[p_inventory_index]
		local next_m_item = m_item[next_inventory_data.key]
		gui.play_flipbook(next_node, next_inventory_data.key .. "_active")
		local next_item_dialog = get_item_dialog(next_m_item)
		m_dtypewriter.load(next_item_dialog)
		m_dtypewriter.start()
	end
	local selector_node = gui.get_node(c_selector_inventory)
	gui.set_position(selector_node, gui.get_position(next_node))
end

local function select_action_index(index)
	local previous_node = gui.get_node(p_action_ids[p_action_index])
	gui.set_color(previous_node, m_dcolors.palette.brown_4)
	if index < 1 then
		p_action_index = #p_action_ids + index
	elseif index > #p_action_ids then
		p_action_index = index - #p_action_ids
	else
		p_action_index = index
	end
	local next_node = gui.get_node(p_action_ids[p_action_index])
	gui.set_color(next_node, m_dcolors.palette.brown_1)
end

local function select_party_index(index)
	local previous_node = gui.get_node(p_party_ids[p_party_index])
	gui.set_color(previous_node, m_dcolors.palette.brown_4)
	if index < 1 then
		p_party_index = #p_party_ids + index
	elseif index > #p_party_ids then
		p_party_index = index - #p_party_ids
	else
		p_party_index = index
	end
	local next_node = gui.get_node(p_party_ids[p_party_index])
	gui.set_color(next_node, m_dcolors.palette.brown_1)
	refresh_stats_background()
end

local function toggle_action_background(flag)
	local node_action_background = gui.get_node(c_action_background)
	gui.set_enabled(node_action_background, flag)
	if flag then
		p_action_ids = {}
		local node_use = gui.get_node(c_use)
		gui.set_color(node_use, m_dcolors.palette.brown_3)
		local node_equip = gui.get_node(c_equip)
		gui.set_color(node_equip, m_dcolors.palette.brown_3)
		local node_consume = gui.get_node(c_consume)
		gui.set_color(node_consume, m_dcolors.palette.brown_3)
		local node_drop = gui.get_node(c_drop)
		gui.set_color(node_drop, m_dcolors.palette.brown_3)
		local data = m_item[p_inventory[p_inventory_index].key]
		if data.use then
			gui.set_color(node_use, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_use
		end
		if data.equip then
			gui.set_color(node_equip, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_equip
		end
		if data.consume then
			gui.set_color(node_consume, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_consume
		end
		if data.drop then
			gui.set_color(node_drop, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_drop
		end
		select_action_index(1)
	end
end

local function toggle_party_background(flag)
	local node_party_background = gui.get_node(c_party_background)
	gui.set_enabled(node_party_background, flag)
	local node_spinner = gui.get_node(c_spinner)
	gui.set_enabled(node_spinner, false)
	if flag then
		local node_party_x = gui.get_node(hash("party_" .. p_party_index))
		gui.set_color(node_party_x, m_dcolors.palette.brown_4)
		select_party_index(1)
	end
end

local function toggle_stats_background(flag)
	local node_stats_background = gui.get_node(c_stats_background)
	gui.set_enabled(node_stats_background, flag)
	if flag then
		refresh_stats_background()
	else
		local item = m_item[p_inventory[p_inventory_index].key]
		local item_dialog = get_item_dialog(item)
		m_dtypewriter.load(item_dialog)
		m_dtypewriter.start()
	end
end

local function on_input_dtypewriter(action_id)
	if action_id == c_key_lctrl then
		if m_dtypewriter.is_waiting() then
			m_dtypewriter.continue()
		elseif m_dtypewriter.is_complete() then
			local item = m_item[p_inventory[p_inventory_index].key]
			local item_dialog = get_item_dialog(item)
			m_dtypewriter.load(item_dialog)
			m_dtypewriter.start()
		end
	end
end

--------------------------------------------------------------------------------
-- ENGINE FUNCTIONS
--------------------------------------------------------------------------------

function init(self)
	msg.post(msg.url(), c_acquire_input_focus)
	m_dtypewriter.init(c_dialog_background, c_monogram, 5, 1, 226, 3, 2, msg.url())
	load_inventory()
	load_party()
	select_inventory_index(1)
end

function on_input(self, action_id, action)
	if action.pressed then
		if p_state == c_state_inventory then
			on_input_dtypewriter(action_id)
			if action_id == c_key_up then
				select_inventory_index(p_inventory_index - 3)
			elseif action_id == c_key_left then
				select_inventory_index(p_inventory_index % 3 == 1 and p_inventory_index + 2 or p_inventory_index - 1)
			elseif action_id == c_key_down then
				select_inventory_index(p_inventory_index + 3)
			elseif action_id == c_key_right then
				select_inventory_index(p_inventory_index % 3 == 0 and p_inventory_index - 2 or p_inventory_index + 1)
			elseif action_id == c_key_z then
				m_dtypewriter.clear()
				m_monarch.back()
			elseif action_id == c_key_x then
				if p_inventory[p_inventory_index] then
					p_state = c_state_action
					toggle_action_background(true)
				end
			end
		elseif p_state == c_state_action then
			on_input_dtypewriter(action_id)
			if action_id == c_key_up then
				select_action_index(p_action_index - 1)
			elseif action_id == c_key_down then
				select_action_index(p_action_index + 1)
			elseif action_id == c_key_z then
				p_state = c_state_inventory
				toggle_action_background(false)
			elseif action_id == c_key_x then
				if p_action_ids[p_action_index] == c_use then
					-- todo
				elseif p_action_ids[p_action_index] == c_equip then
					p_state = c_state_party
					toggle_party_background(true)
					toggle_stats_background(true)
				elseif p_action_ids[p_action_index] == c_consume then
					p_state = c_state_party
					toggle_party_background(true)
				elseif p_action_ids[p_action_index] == c_drop then
					-- todo
				end
			end
		elseif p_state == c_state_party then
			if action_id == c_key_up then
				select_party_index(p_party_index - 1)
			elseif action_id == c_key_down then
				select_party_index(p_party_index + 1)
			elseif action_id == c_key_z then
				p_state = c_state_action
				toggle_party_background(false)
				toggle_stats_background(false)
			elseif action_id == c_key_x then
				-- todo
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if p_state == c_state_inventory or p_state == c_state_action then
		if message_id == m_dtypewriter.messages.start then
			gui.set_enabled(gui.get_node(c_spinner), false)
		elseif message_id == m_dtypewriter.messages.wait then
			gui.set_enabled(gui.get_node(c_spinner), true)
		elseif message_id == m_dtypewriter.messages.continue then
			gui.set_enabled(gui.get_node(c_spinner), false)
		elseif message_id == m_dtypewriter.messages.complete then
			gui.set_enabled(gui.get_node(c_spinner), true)
		elseif message_id == m_dtypewriter.messages.clear then
			gui.set_enabled(gui.get_node(c_spinner), false)
		end
	end
end