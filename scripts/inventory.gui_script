--------------------------------------------------------------------------------
-- DEPENDENCIES
--------------------------------------------------------------------------------

local m_character = require "modules.character"
local m_item = require "modules.item"
local m_persist = require "modules.persist"
local m_utility = require "modules.utility"
local m_dcolors = require "dcolors.dcolors"
local m_dtypewriter = require "dtypewriter.dtypewriter"
local m_monarch = require "monarch.monarch"

--------------------------------------------------------------------------------
-- CONSTANTS
--------------------------------------------------------------------------------

local c_acquire_input_focus = hash("acquire_input_focus")

local c_monogram = hash("monogram")

local c_state_inventory = hash("state_inventory")
local c_state_action = hash("state_action")
local c_state_party = hash("state_party")

local c_selector = hash("selector")

local c_dialog_background = hash("dialog_background")
local c_action_background = hash("action_background")
local c_party_background = hash("party_background")
local c_stats_background = hash("stats_background")

local c_use = hash("use")
local c_consume = hash("consume")
local c_equip = hash("equip")
local c_drop = hash("drop")

local c_spinner = hash("spinner")

local c_key_w = hash("key_w")
local c_key_a = hash("key_a")
local c_key_s = hash("key_s")
local c_key_d = hash("key_d")
local c_key_q = hash("key_q")
local c_key_e = hash("key_e")
local c_key_lshift = hash("key_lshift")
local c_key_space = hash("key_space")
local c_key_enter = hash("key_enter")

local c_stats_list = { "health", "strength", "defense", "agility", "wonder", "terra" }
local c_equipment_list = { "hands", "head", "torso", "trunk", "feet", "ring", "bracelet", "necklace" }

--------------------------------------------------------------------------------
-- PROPERTIES
--------------------------------------------------------------------------------

local p_state = c_state_inventory

local p_inventory_index = 1
local p_inventory = {}

local p_action_index = 1
local p_action_ids = {}

local p_party_index = 1
local p_party_ids = {}
local p_party = {}

local p_timer_handles = {}

local p_persist_stat = {}

--------------------------------------------------------------------------------
-- LOCAL FUNCTIONS
--------------------------------------------------------------------------------

local function get_description_dialog(item)
	return "<color=item>" .. item.name .. "<color=default><line>" .. item.description
end

local function get_consume_dialog(player_name, item)
	local result = "Consume <color=item>" .. item.name .. "<color=default> as <color=character>" .. player_name .. "<color=default>?<paragraph>"
	if item.health_restore > 0 then
		result = result .. "<color=stat>Health Restore<color=default> = " .. item.health_restore .. "<line>"
	end
	if item.health_buffer > 0 then
		result = result .. "<color=stat>Health Buffer<color=default> = " .. item.health_buffer .. "<line>"
	end
	if item.strength_restore > 0 then
		result = result .. "<color=stat>Strength Restore<color=default> = " .. item.strength_restore .. "<line>"
	end
	if item.strength_buffer > 0 then
		result = result .. "<color=stat>Strength Buffer<color=default> = " .. item.strength_buffer .. "<line>"
	end
	if item.defense_restore > 0 then
		result = result .. "<color=stat>Defense Restore<color=default> = " .. item.defense_restore .. "<line>"
	end
	if item.defense_buffer > 0 then
		result = result .. "<color=stat>Defense Buffer<color=default> = " .. item.defense_buffer .. "<line>"
	end
	if item.agility_restore > 0 then
		result = result .. "<color=stat>Agility Restore<color=default> = " .. item.agility_restore .. "<line>"
	end
	if item.agility_buffer > 0 then
		result = result .. "<color=stat>Agility Buffer<color=default> = " .. item.agility_buffer .. "<line>"
	end
	if item.wonder_restore > 0 then
		result = result .. "<color=stat>Wonder Restore<color=default> = " .. item.wonder_restore .. "<line>"
	end
	if item.wonder_buffer > 0 then
		result = result .. "<color=stat>Wonder Buffer<color=default> = " .. item.wonder_buffer .. "<line>"
	end
	if item.terra_restore > 0 then
		result = result .. "<color=stat>Terra Restore<color=default> = " .. item.terra_restore .. "<line>"
	end
	if item.terra_buffer > 0 then
		result = result .. "<color=stat>Terra Buffer<color=default> = " .. item.terra_buffer .. "<line>"
	end
	result = string.sub(result, 1, #result - 6)
	return result
end

local function get_equip_dialog(player_name, item, equipped_item_name)
	local result = "Equip <color=item>" .. item.name .. "<color=default> "
	if equipped_item_name then
		result = result .. "and unequip <color=item>" .. equipped_item_name .. "<color=default> "
	end
	result = result .. "as <color=character>" .. player_name .. "<color=default>?<paragraph>"
	if item.health_equipment > 0 then
		result = result .. "<color=stat>Health Equipment<color=default> = " .. item.health_equipment .. "<line>"
	end
	if item.strength_equipment > 0 then
		result = result .. "<color=stat>Strength Equipment<color=default> = " .. item.strength_equipment .. "<line>"
	end
	if item.defense_equipment > 0 then
		result = result .. "<color=stat>Defense Equipment<color=default> = " .. item.defense_equipment .. "<line>"
	end
	if item.agility_equipment > 0 then
		result = result .. "<color=stat>Agility Equipment<color=default> = " .. item.agility_equipment .. "<line>"
	end
	if item.wonder_equipment > 0 then
		result = result .. "<color=stat>Wonder Equipment<color=default> = " .. item.wonder_equipment .. "<line>"
	end
	if item.terra_equipment > 0 then
		result = result .. "<color=stat>Terra Equipment<color=default> = " .. item.terra_equipment .. "<line>"
	end
	result = string.sub(result, 1, #result - 6)
	return result
end

local function cancel_timer_handles()
	for i = 1, #p_timer_handles do
		timer.cancel(p_timer_handles[i])
	end
	p_timer_handles = {}
end

local function exit_menus()
	m_dtypewriter.clear()
	m_monarch.back()
	m_monarch.back()
end

local function refresh_inventory_nodes()
	for i = 1, #p_inventory do
		local node = gui.get_node(hash("item_" .. i))
		if p_inventory[i] then
			gui.set_enabled(node, true)
			local animation = p_inventory[i].key .. "_idle"
			gui.play_flipbook(node, animation)
		else
			gui.set_enabled(node, false)
		end
	end
end

local function refresh_party_nodes()
	for i = 1, #p_party do
		if p_party[i] then
			p_party_ids[#p_party_ids + 1] = hash("party_" .. i)
			local node = gui.get_node(p_party_ids[#p_party_ids])
			local name = m_character[p_party[i].key].name
			gui.set_text(node, name)
		end
	end
end

local function refresh_stat_static(stat_key, stat_suffix, value)
	local node = gui.get_node(hash(stat_key .. stat_suffix))
	gui.set_text(node, value)
	gui.set_color(node, m_dcolors.palette.brown_4)
end

local function refresh_stat_dynamic(stat_key, stat_suffix, value_old, value_new)
	local node = gui.get_node(hash(stat_key .. stat_suffix))
	gui.set_text(node, value_new)
	gui.set_color(node, value_old == value_new and m_dcolors.palette.brown_4 or (value_old < value_new and m_dcolors.palette.green or m_dcolors.palette.red))
	if value_old ~= value_new then
		p_persist_stat[#p_persist_stat + 1] = { key = stat_key, suffix = stat_suffix, value = value_new }
		p_timer_handles[#p_timer_handles + 1] = timer.delay(0.75, true, function()
			local number = tonumber(gui.get_text(node))
			if number == value_old then
				gui.set_text(node, value_new)
				gui.set_color(node, value_old < value_new and m_dcolors.palette.green or m_dcolors.palette.red)
			else
				gui.set_text(node, value_old)
				gui.set_color(node, m_dcolors.palette.brown_4)
			end
		end)
	end
end

local function refresh_stats_consume()
	cancel_timer_handles()
	p_persist_stat = {}
	local item = m_item[p_inventory[p_inventory_index].key]
	local player = p_party[p_party_index]
	for i = 1, #c_stats_list do
		local stat_key = c_stats_list[i]
		local level_value = player[stat_key .. "_level"]
		refresh_stat_static(stat_key, "_level", level_value)
		local equipment_value = player[stat_key .. "_equipment"]
		refresh_stat_static(stat_key, "_equipment", equipment_value)
		local buffer_value_old = player[stat_key .. "_buffer"]
		local buffer_value_new = buffer_value_old + item[stat_key .. "_buffer"]
		refresh_stat_dynamic(stat_key, "_buffer", buffer_value_old, buffer_value_new)
		local total_value_old = player[stat_key .. "_total"]
		local total_value_new = total_value_old + buffer_value_new
		refresh_stat_dynamic(stat_key, "_total", total_value_old, total_value_new)
		local current_value_old = player[stat_key .. "_current"]
		local current_value_new = current_value_old + buffer_value_new - buffer_value_old
		current_value_new = math.min(current_value_new + item[stat_key .. "_restore"], total_value_new)
		refresh_stat_dynamic(stat_key, "_current", current_value_old, current_value_new)
	end
	local player_name = m_character[player.key].name
	local dialog = get_consume_dialog(player_name, item)
	m_dtypewriter.load(dialog)
	m_dtypewriter.start()
end

local function refresh_stats_equip()
	cancel_timer_handles()
	p_persist_stat = {}
	local item = m_item[p_inventory[p_inventory_index].key]
	local player = p_party[p_party_index]
	local equipped_item = player[item.equip_key .. "_key"] and m_item[player[item.equip_key .. "_key"]] or {}
	for i = 1, #c_stats_list do
		local stat_key = c_stats_list[i]
		local level_value = player[stat_key .. "_level"]
		refresh_stat_static(stat_key, "_level", level_value)
		local equipment_value_old = player[stat_key .. "_equipment"]
		local equipment_value_new = equipment_value_old - (equipped_item[stat_key .. "_equipment"] or 0) + item[stat_key .. "_equipment"]
		refresh_stat_dynamic(stat_key, "_equipment", equipment_value_old, equipment_value_new)
		local buffer_value = player[stat_key .. "_buffer"]
		refresh_stat_static(stat_key, "_buffer", buffer_value)
		local total_value_old = buffer_value + equipment_value_old + level_value
		local total_value_new = buffer_value + equipment_value_new + level_value
		refresh_stat_dynamic(stat_key, "_total", total_value_old, total_value_new)
		local current_value_old = player[stat_key .. "_current"]
		local current_value_new = current_value_old + equipment_value_new - equipment_value_old
		refresh_stat_dynamic(stat_key, "_current", current_value_old, current_value_new)
	end
	local player_name = m_character[player.key].name
	local dialog = get_equip_dialog(player_name, item, equipped_item.name)
	m_dtypewriter.load(dialog)
	m_dtypewriter.start()
end

local function select_inventory_index(index)
	if not m_dtypewriter.is_clear() then
		m_dtypewriter.clear()
	end
	if p_inventory[p_inventory_index] then
		local previous_node = gui.get_node(hash("item_" .. p_inventory_index))
		gui.play_flipbook(previous_node, p_inventory[p_inventory_index].key .. "_idle")
	end
	p_inventory_index = m_utility.wrap(index, 1, #p_inventory)
	local next_node = gui.get_node(hash("item_" .. p_inventory_index))
	if p_inventory[p_inventory_index] then
		local next_item_key = p_inventory[p_inventory_index].key
		local next_item = m_item[next_item_key]
		gui.play_flipbook(next_node, next_item_key .. "_active")
		local dialog = get_description_dialog(next_item)
		m_dtypewriter.load(dialog)
		m_dtypewriter.start()
	end
	local selector_node = gui.get_node(c_selector)
	gui.set_position(selector_node, gui.get_position(next_node))
end

local function select_action_index(index)
	local previous_node = gui.get_node(p_action_ids[p_action_index])
	gui.set_color(previous_node, m_dcolors.palette.brown_4)
	p_action_index = m_utility.wrap(index, 1, #p_action_ids)
	local next_node = gui.get_node(p_action_ids[p_action_index])
	gui.set_color(next_node, m_dcolors.palette.brown_1)
end

local function select_party_index(index)
	local previous_node = gui.get_node(p_party_ids[p_party_index])
	gui.set_color(previous_node, m_dcolors.palette.brown_4)
	p_party_index = m_utility.wrap(index, 1, #p_party_ids)
	local next_node = gui.get_node(p_party_ids[p_party_index])
	gui.set_color(next_node, m_dcolors.palette.brown_1)
	if p_action_ids[p_action_index] == c_consume then
		refresh_stats_consume()
	elseif p_action_ids[p_action_index] == c_equip then
		refresh_stats_equip()
	end
end

local function toggle_action_background(flag)
	local node_action_background = gui.get_node(c_action_background)
	gui.set_enabled(node_action_background, flag)
	if flag then
		p_action_ids = {}
		local node_use = gui.get_node(c_use)
		gui.set_color(node_use, m_dcolors.palette.brown_3)
		local node_equip = gui.get_node(c_equip)
		gui.set_color(node_equip, m_dcolors.palette.brown_3)
		local node_consume = gui.get_node(c_consume)
		gui.set_color(node_consume, m_dcolors.palette.brown_3)
		local node_drop = gui.get_node(c_drop)
		gui.set_color(node_drop, m_dcolors.palette.brown_3)
		local item = m_item[p_inventory[p_inventory_index].key]
		if item.use then
			gui.set_color(node_use, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_use
		end
		if item.equip then
			gui.set_color(node_equip, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_equip
		end
		if item.consume then
			gui.set_color(node_consume, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_consume
		end
		if item.drop then
			gui.set_color(node_drop, m_dcolors.palette.brown_4)
			p_action_ids[#p_action_ids + 1] = c_drop
		end
		select_action_index(1)
	end
end

local function toggle_party_background(flag)
	local node_party_background = gui.get_node(c_party_background)
	gui.set_enabled(node_party_background, flag)
	local node_stats_background = gui.get_node(c_stats_background)
	gui.set_enabled(node_stats_background, flag)
	if flag then
		local node_player = gui.get_node(hash("party_" .. p_party_index))
		gui.set_color(node_player, m_dcolors.palette.brown_4)
		select_party_index(1)
	else
		cancel_timer_handles()
		select_inventory_index(p_inventory_index)
	end
end

local function consume_item()
	for i = 1, #p_persist_stat do
		local persist_stat = p_persist_stat[i]
		m_persist.set_party_stat(p_party_index, persist_stat.key, persist_stat.suffix, persist_stat.value)
	end
	local item_count = p_inventory[p_inventory_index].count - 1
	if item_count > 0 then
		m_persist.set_inventory_item_count(p_inventory_index, item_count)
	else
		m_persist.set_inventory_item_nil(p_inventory_index)
	end
end

local function equip_item()
	for i = 1, #p_persist_stat do
		local persist_stat = p_persist_stat[i]
		m_persist.set_party_stat(p_party_index, persist_stat.key, persist_stat.suffix, persist_stat.value)
	end
	local item_key_new = p_inventory[p_inventory_index].key
	local equip_key = m_item[item_key_new].equip_key
	m_persist.set_party_equipment(p_party_index, equip_key, item_key_new)
	local item_key_old = p_party[p_party_index][equip_key .. "_key"]
	if item_key_old then
		m_persist.set_inventory_item(p_inventory_index, item_key_old)
	else
		m_persist.set_inventory_item_nil(p_inventory_index)
	end
end

local function select_player()
	if p_action_ids[p_action_index] == c_consume then
		consume_item()
	elseif p_action_ids[p_action_index] == c_equip then
		equip_item()
	end
	p_state = c_state_inventory
	toggle_party_background(false)
	toggle_action_background(false)
	p_inventory = m_persist.get_inventory()
	p_party = m_persist.get_party()
	refresh_inventory_nodes()
	select_inventory_index(p_inventory_index)
end

--------------------------------------------------------------------------------
-- ENGINE FUNCTIONS
--------------------------------------------------------------------------------

function init(self)
	msg.post(msg.url(), c_acquire_input_focus)
	m_dtypewriter.init(c_dialog_background, c_monogram, 5, 1, 226, 3, 2, msg.url())
	m_dtypewriter.set_default_type_speed(0)
	p_inventory = m_persist.get_inventory()
	p_party = m_persist.get_party()
	refresh_inventory_nodes()
	refresh_party_nodes()
	select_inventory_index(1)
end

function on_input(self, action_id, action)
	if action.pressed then
		if action_id == c_key_space then
			if m_dtypewriter.is_waiting() then
				m_dtypewriter.continue()
			elseif m_dtypewriter.is_complete() then
				m_dtypewriter.restart()
				m_dtypewriter.start()
			end
		end
		if p_state == c_state_inventory then
			if action_id == c_key_w then
				select_inventory_index(p_inventory_index - 3)
			elseif action_id == c_key_a then
				select_inventory_index(p_inventory_index % 3 == 1 and p_inventory_index + 2 or p_inventory_index - 1)
			elseif action_id == c_key_s then
				select_inventory_index(p_inventory_index + 3)
			elseif action_id == c_key_d then
				select_inventory_index(p_inventory_index % 3 == 0 and p_inventory_index - 2 or p_inventory_index + 1)
			elseif action_id == c_key_q then
				m_dtypewriter.clear()
				m_monarch.back()
			elseif action_id == c_key_e then
				if p_inventory[p_inventory_index] then
					p_state = c_state_action
					toggle_action_background(true)
				end
			elseif action_id == c_key_enter then
				exit_menus()
			end
		elseif p_state == c_state_action then
			if action_id == c_key_w then
				select_action_index(p_action_index - 1)
			elseif action_id == c_key_s then
				select_action_index(p_action_index + 1)
			elseif action_id == c_key_q then
				p_state = c_state_inventory
				toggle_action_background(false)
			elseif action_id == c_key_e then
				if p_action_ids[p_action_index] == c_use then
					-- todo
				elseif p_action_ids[p_action_index] == c_equip then
					p_state = c_state_party
					toggle_party_background(true)
				elseif p_action_ids[p_action_index] == c_consume then
					p_state = c_state_party
					toggle_party_background(true)
				elseif p_action_ids[p_action_index] == c_drop then
					-- todo
				end
			elseif action_id == c_key_enter then
				exit_menus()
			end
		elseif p_state == c_state_party then
			if action_id == c_key_w then
				select_party_index(p_party_index - 1)
			elseif action_id == c_key_s then
				select_party_index(p_party_index + 1)
			elseif action_id == c_key_q then
				p_state = c_state_inventory
				toggle_party_background(false)
				toggle_action_background(false)
			elseif action_id == c_key_e then
				select_player()
			elseif action_id == c_key_enter then
				exit_menus()
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == m_dtypewriter.messages.start or message_id == m_dtypewriter.messages.restart or message_id == m_dtypewriter.messages.continue or message_id == m_dtypewriter.messages.clear then
		gui.set_enabled(gui.get_node(c_spinner), false)
	elseif message_id == m_dtypewriter.messages.wait or message_id == m_dtypewriter.messages.complete then
		gui.set_enabled(gui.get_node(c_spinner), true)
	end
end