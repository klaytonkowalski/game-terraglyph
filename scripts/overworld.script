local h_str = require "modules.h_str"
local persist = require "modules.persist"
local map_data = require "modules.map_data"
local dgrid = require "dgrid.dgrid"
local dtile = require "dtile.dtile"

local map_id
local map_objects

local tilesource_handle
local tilesource_id
local tilesource_animation = 0

go.property("tilesource_1_0", resource.tile_source("/tilesources/tilesource_1_0.tilesource"))
go.property("tilesource_1_1", resource.tile_source("/tilesources/tilesource_1_1.tilesource"))
go.property("tilesource_1_2", resource.tile_source("/tilesources/tilesource_1_2.tilesource"))
go.property("tilesource_1_3", resource.tile_source("/tilesources/tilesource_1_3.tilesource"))
go.property("tilesource_1_4", resource.tile_source("/tilesources/tilesource_1_4.tilesource"))
go.property("tilesource_1_5", resource.tile_source("/tilesources/tilesource_1_5.tilesource"))
go.property("tilesource_1_6", resource.tile_source("/tilesources/tilesource_1_6.tilesource"))
go.property("tilesource_1_7", resource.tile_source("/tilesources/tilesource_1_7.tilesource"))

local function generate_collision_tags(tilemap_url, tilemap_width, tilemap_height)
	local collision_tags = {}
	for y = tilemap_height, 1, -1 do
		collision_tags[#collision_tags + 1] = {}
		for x = 1, tilemap_width do
			collision_tags[#collision_tags][x] = tilemap.get_tile(tilemap_url, h_str.layer_collision, x, y) - 248
		end
	end
	dgrid.set_map_tags(collision_tags)
end

local function generate_map_data(tilemap_url, tilemap_width, tilemap_height)
	for _, layer in ipairs({ h_str.layer_terrain, h_str.layer_object, h_str.layer_canopy }) do
		for y = tilemap_height, 1, -1 do
			for x = 1, tilemap_width do
				local tile_id = tilemap.get_tile(tilemap_url, layer, x, y)
				local tile_data = dgrid.get_tile_data(x, y)
				if map_data.tilesources[tilesource_id][tile_id] then
					for key, value in pairs(map_data.tilesources[tilesource_id][tile_id]) do
						tile_data[key] = value
					end
				end
				for _, other_tile_data in ipairs(map_data.tiles[map_id]) do
					if other_tile_data.x == x and other_tile_data.y == y then
						for key, value in pairs(other_tile_data.data) do
							tile_data[key] = value
						end
					end
				end
			end
		end
	end
end

local function update_tilesource(self)
	tilesource_animation = tilesource_animation + 1
	if tilesource_animation == 8 then
		tilesource_animation = 0
	end
	go.set(msg.url(nil, map_objects[hash("/tilemap")], "tilemap"), "tile_source", self["tilesource_" .. tilesource_id .. "_" .. tilesource_animation])
end

function init(self)
	dgrid.set_tile_dimensions(16, 16)
	dgrid.add_map_tag(h_str.collision_water, false)
	local continue_data = persist.get_continue_data()
	map_id = continue_data.map_id
	map_objects = collectionfactory.create(msg.url(nil, hash("/factory_overworld"), "collectionfactory_map_" .. continue_data.map_id))
	tilesource_id = map_data.map_to_tilesource[continue_data.map_id]
	local tilemap_url = msg.url(nil, map_objects[hash("/tilemap")], "tilemap")
	local _, _, tilemap_width, tilemap_height = tilemap.get_bounds(tilemap_url)
	dgrid.set_map_dimensions(tilemap_width, tilemap_height)
	generate_collision_tags(tilemap_url, tilemap_width, tilemap_height)
	generate_map_data(tilemap_url, tilemap_width, tilemap_height)
	go.set_parent(hash("/camera_overworld"), map_objects[hash("/player")])
	dtile.init(map_data.animations[tilesource_id], tilemap_url, { h_str.layer_terrain, h_str.layer_object, h_str.layer_canopy })
	tilesource_handle = timer.delay(0.25, true, update_tilesource)
	msg.post(msg.url(nil, map_objects[hash("/controller")], "script"), h_str.message_set_receiver, { id = map_objects[hash("/player")] })
end

function update(self, dt)
	dgrid.update(dt)
end

function on_message(self, message_id, message, sender)
	if message_id == h_str.message_command_lock then
		dgrid.toggle_entity_input(map_objects[message.id], false)
	elseif message_id == h_str.message_command_unlock then
		dgrid.toggle_entity_input(map_objects[message.id], true)
	end
end